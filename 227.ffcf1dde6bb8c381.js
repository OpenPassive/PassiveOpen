"use strict";(self.webpackChunkpassiveopen=self.webpackChunkpassiveopen||[]).push([[227],{7490:(I,y,E)=>{E.d(y,{Z:()=>U});var T=E(5861);function k(l,c){let i=l.length-c,a=0;do{for(let t=c;t>0;t--)l[a+c]+=l[a],a++;i-=c}while(i>0)}function A(l,c,i){let a=0,t=l.length;const s=t/i;for(;t>c;){for(let n=c;n>0;--n)l[a+c]+=l[a],++a;t-=c}const o=l.slice();for(let n=0;n<s;++n)for(let e=0;e<i;++e)l[i*n+e]=o[(i-e-1)*s+n]}class U{decode(c,i){var a=this;return(0,T.Z)(function*(){const t=yield a.decodeBlock(i),s=c.Predictor||1;if(1!==s){const o=!c.StripOffsets;return function v(l,c,i,a,t,s){if(!c||1===c)return l;for(let e=0;e<t.length;++e){if(t[e]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(t[e]!==t[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const o=t[0]/8,n=2===s?1:t.length;for(let e=0;e<a&&!(e*n*i*o>=l.byteLength);++e){let f;if(2===c){switch(t[0]){case 8:f=new Uint8Array(l,e*n*i*o,n*i*o);break;case 16:f=new Uint16Array(l,e*n*i*o,n*i*o/2);break;case 32:f=new Uint32Array(l,e*n*i*o,n*i*o/4);break;default:throw new Error(`Predictor 2 not allowed with ${t[0]} bits per sample.`)}k(f,n)}else 3===c&&(f=new Uint8Array(l,e*n*i*o,n*i*o),A(f,n,o))}return l}(t,s,o?c.TileWidth:c.ImageWidth,o?c.TileLength:c.RowsPerStrip||c.ImageLength,c.BitsPerSample,c.PlanarConfiguration)}return t})()}}},8227:(I,y,E)=>{E.r(y),E.d(y,{default:()=>a});var T=E(7490);function c(t,s){for(let o=s.length-1;o>=0;o--)t.push(s[o]);return t}class a extends T.Z{decodeBlock(s){return function i(t){const s=new Uint16Array(4093),o=new Uint8Array(4093);for(let r=0;r<=257;r++)s[r]=4096,o[r]=r;let n=258,e=9,f=0;function C(){n=258,e=9}function g(r){const _=function l(t,s,o){const n=s%8,e=Math.floor(s/8),f=8-n,C=s+o-8*(e+1);let g=8*(e+2)-(s+o);const B=8*(e+2)-s;if(g=Math.max(0,g),e>=t.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;let p=t[e]&2**(8-n)-1;p<<=o-f;let u=p;if(e+1<t.length){let h=t[e+1]>>>g;h<<=Math.max(0,o-B),u+=h}return C>8&&e+2<t.length&&(u+=t[e+2]>>>8*(e+3)-(s+o)),u}(r,f,e);return f+=e,_}function B(r,_){return o[n]=_,s[n]=r,n++,n-1}function p(r){const _=[];for(let L=r;4096!==L;L=s[L])_.push(o[L]);return _}const u=[];C();const h=new Uint8Array(t);let w,d=g(h);for(;257!==d;){if(256===d){for(C(),d=g(h);256===d;)d=g(h);if(257===d)break;if(d>256)throw new Error(`corrupted code at scanline ${d}`);c(u,p(d)),w=d}else if(d<n){const r=p(d);c(u,r),B(w,r[r.length-1]),w=d}else{const r=p(w);if(!r)throw new Error(`Bogus entry. Not in dictionary, ${w} / ${n}, position: ${f}`);c(u,r),u.push(r[r.length-1]),B(w,r[r.length-1]),w=d}n+1>=2**e&&(12===e?w=void 0:e++),d=g(h)}return new Uint8Array(u)}(s).buffer}}}}]);