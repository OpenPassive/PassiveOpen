"use strict";(self.webpackChunkpassiveopen=self.webpackChunkpassiveopen||[]).push([[503],{7490:(U,h,r)=>{r.d(h,{Z:()=>u});var g=r(5861);function w(t,e){let n=t.length-e,c=0;do{for(let o=e;o>0;o--)t[c+e]+=t[c],c++;n-=e}while(n>0)}function p(t,e,n){let c=0,o=t.length;const l=o/n;for(;o>e;){for(let s=e;s>0;--s)t[c+e]+=t[c],++c;o-=e}const d=t.slice();for(let s=0;s<l;++s)for(let a=0;a<n;++a)t[n*s+a]=d[(n-a-1)*l+s]}class u{decode(e,n){var c=this;return(0,g.Z)(function*(){const o=yield c.decodeBlock(n),l=e.Predictor||1;if(1!==l){const d=!e.StripOffsets;return function f(t,e,n,c,o,l){if(!e||1===e)return t;for(let a=0;a<o.length;++a){if(o[a]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(o[a]!==o[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const d=o[0]/8,s=2===l?1:o.length;for(let a=0;a<c&&!(a*s*n*d>=t.byteLength);++a){let i;if(2===e){switch(o[0]){case 8:i=new Uint8Array(t,a*s*n*d,s*n*d);break;case 16:i=new Uint16Array(t,a*s*n*d,s*n*d/2);break;case 32:i=new Uint32Array(t,a*s*n*d,s*n*d/4);break;default:throw new Error(`Predictor 2 not allowed with ${o[0]} bits per sample.`)}w(i,s)}else 3===e&&(i=new Uint8Array(t,a*s*n*d,s*n*d),p(i,s,d))}return t}(o,l,d?e.TileWidth:e.ImageWidth,d?e.TileLength:e.RowsPerStrip||e.ImageLength,e.BitsPerSample,e.PlanarConfiguration)}return o})()}}},6503:(U,h,r)=>{r.r(h),r.d(h,{default:()=>w});var g=r(7490);class w extends g.Z{decodeBlock(f){const u=new DataView(f),t=[];for(let e=0;e<f.byteLength;++e){let n=u.getInt8(e);if(n<0){const c=u.getUint8(e+1);n=-n;for(let o=0;o<=n;++o)t.push(c);e+=1}else{for(let c=0;c<=n;++c)t.push(u.getUint8(e+c+1));e+=n+1}}return new Uint8Array(t).buffer}}}}]);