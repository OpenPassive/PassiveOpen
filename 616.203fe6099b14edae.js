"use strict";(self.webpackChunkpassiveopen=self.webpackChunkpassiveopen||[]).push([[616],{7490:(p,h,r)=>{r.d(h,{Z:()=>_});var i=r(5861);function f(s,e){let t=s.length-e,d=0;do{for(let a=e;a>0;a--)s[d+e]+=s[d],d++;t-=e}while(t>0)}function w(s,e,t){let d=0,a=s.length;const l=a/t;for(;a>e;){for(let n=e;n>0;--n)s[d+e]+=s[d],++d;a-=e}const c=s.slice();for(let n=0;n<l;++n)for(let o=0;o<t;++o)s[t*n+o]=c[(t-o-1)*l+n]}class _{decode(e,t){var d=this;return(0,i.Z)(function*(){const a=yield d.decodeBlock(t),l=e.Predictor||1;if(1!==l){const c=!e.StripOffsets;return function g(s,e,t,d,a,l){if(!e||1===e)return s;for(let o=0;o<a.length;++o){if(a[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[o]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const c=a[0]/8,n=2===l?1:a.length;for(let o=0;o<d&&!(o*n*t*c>=s.byteLength);++o){let u;if(2===e){switch(a[0]){case 8:u=new Uint8Array(s,o*n*t*c,n*t*c);break;case 16:u=new Uint16Array(s,o*n*t*c,n*t*c/2);break;case 32:u=new Uint32Array(s,o*n*t*c,n*t*c/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}f(u,n)}else 3===e&&(u=new Uint8Array(s,o*n*t*c,n*t*c),w(u,n,c))}return s}(a,l,c?e.TileWidth:e.ImageWidth,c?e.TileLength:e.RowsPerStrip||e.ImageLength,e.BitsPerSample,e.PlanarConfiguration)}return a})()}}},616:(p,h,r)=>{r.r(h),r.d(h,{default:()=>f});var i=r(7490);class f extends i.Z{decodeBlock(g){return g}}}}]);